import { useState, useEffect } from "react";
import axios from "axios";
import { useFormik } from "formik";
import * as Yup from "yup";
import "../cssFiles/customColors.css";

interface UserIEFormData {
	[key: string]: any;
}

const initialFormData: UserIEFormData = {};

function UserIEInformation() {
	const [formSections, setFormSections] = useState<{ [key: string]: any[] }>(
		{}
	);
	const [validationSchemaData, setValidationSchemaData] = useState<any[]>([]);
	const [openIndexes, setOpenIndexes] = useState<number[]>([]); // Track which sections are open

	useEffect(() => {
		axios
			.get("http://localhost:3001/userinfoIE")
			.then((response) => {
				formik.setValues(response.data);
				if (response.data.profilePicture) {
					// Handle profile picture if needed
				}
			})
			.catch((error) => {
				console.error("Error fetching userIE data:", error);
			});
	}, []);

	useEffect(() => {
		axios
			.get("http://localhost:3001/formFieldsIE")
			.then((response) => {
				const sections = response.data[0];
				setFormSections(sections);
				console.log(response.data[0]);
			})
			.catch((error) => {
				console.error("Error fetching form fields:", error);
			});
	}, []);

	useEffect(() => {
		axios
			.get("http://localhost:3001/validationSchemaDataIE")
			.then((response) => {
				setValidationSchemaData(response.data);
			})
			.catch((error) => {
				console.error("Error fetching custom validation schema:", error);
			});
	}, []);

	const validationSchema = Yup.object().shape(
		validationSchemaData.reduce((acc, rule) => {
			let fieldSchema: Yup.AnySchema = Yup.mixed();

			switch (rule.type) {
				case "string":
					fieldSchema = Yup.string();
					break;
				case "date":
					fieldSchema = Yup.date();
					break;
				default:
					fieldSchema = Yup.mixed();
			}

			if (rule.matches && rule.type === "string") {
				fieldSchema = (fieldSchema as Yup.StringSchema).matches(
					new RegExp(rule.matches[0]),
					rule.matches[1]
				);
			}
			if (rule.email) {
				fieldSchema = (fieldSchema as Yup.StringSchema).email(rule.email);
			}

			if (rule.when) {
				const [depField, conditions] = rule.when;
				fieldSchema = fieldSchema.when(depField, {
					is: conditions.is,
					then: (schema) => {
						let thenSchema = schema;
						if (conditions.then.matches) {
							thenSchema = (thenSchema as Yup.StringSchema).matches(
								new RegExp(conditions.then.matches[0]),
								conditions.then.matches[1]
							);
						}
						if (conditions.then.required === false) {
							thenSchema = thenSchema.notRequired();
						} else if (conditions.then.required) {
							thenSchema = thenSchema.required(conditions.then.required);
						}
						return thenSchema;
					},
					otherwise: (schema) => {
						let otherwiseSchema = schema;
						if (conditions.otherwise.matches) {
							otherwiseSchema = (otherwiseSchema as Yup.StringSchema).matches(
								new RegExp(conditions.otherwise.matches[0]),
								conditions.otherwise.matches[1]
							);
						}
						if (conditions.otherwise.required === false) {
							otherwiseSchema = otherwiseSchema.notRequired();
						} else if (conditions.otherwise.required) {
							otherwiseSchema = otherwiseSchema.required(
								conditions.otherwise.required
							);
						}
						return otherwiseSchema;
					},
				});
			} else {
				if (rule.required) {
					fieldSchema = fieldSchema.required(rule.required);
				} else if (rule.optional) {
					fieldSchema = fieldSchema.notRequired();
				}
			}

			acc[rule.name] = fieldSchema as Yup.Schema<any>;
			return acc;
		}, {} as Yup.ObjectSchema<any>)
	);

	const formik = useFormik({
		initialValues: initialFormData,
		validationSchema,
		onSubmit: (values) => {
			axios
				.post("http://localhost:3001/submit", values)
				.then((response) => {
					console.log(
						"UserIE information updated successfully:",
						response.data
					);
				})
				.catch((error) => {
					console.error("Error updating userIE information:", error);
				});
		},
		validateOnBlur: true,
		validateOnChange: true,
	});

	const toggleForm = (index: number) => {
		setOpenIndexes((prevOpenIndexes) =>
			prevOpenIndexes.includes(index)
				? prevOpenIndexes.filter((i) => i !== index)
				: [...prevOpenIndexes, index]
		);
	};

	return (
		<div className="custom-bg-4">
			<div className="container d-flex flex-column">
				<form
					onSubmit={formik.handleSubmit}
					className="needs-validation my-5"
					noValidate
				>
					<div className="accordion">
						{Object.keys(formSections).map((section, index) => (
							<div
								className="accordion-item shadow-sm rounded-5 mb-5"
								key={index}
							>
								<div
									className="accordion-header border border-2 border-primary rounded-5 d-flex justify-content-end align-items-center p-2"
									id={`heading${index}`}
								>
									<h3 className="mb-0 ms-auto me-4">{section}</h3>
									<img
										src="src/images/plus-border.png"
										alt="+"
										className={`img-fluid m-0 p-0 btn-toggle ${
											openIndexes.includes(index) ? "rotate" : ""
										}`}
										onClick={() => toggleForm(index)}
										data-bs-toggle="collapse"
										data-bs-target={`#collapse${index}`}
										itemType="button"
										aria-expanded={openIndexes.includes(index)}
										aria-controls={`collapse${index}`}
										style={{ width: "50px", height: "50px" }}
									/>
								</div>
								<div
									id={`collapse${index}`}
									className={`collapse ${
										openIndexes.includes(index) ? "show" : ""
									}`}
									aria-labelledby={`heading${index}`}
								>
									<div className="accordion-body text-end pt-0 mb-1">
										<div className="row row-cols-2 g-5 my-1">
											{Array.isArray(formSections[section]) &&
												formSections[section].map((field: any, idx: number) => {
													const isSelect = field.type === "select";
													const isCheckbox = field.checkboxName;

													return (
														<div key={idx} className="col mb-2">
															<label
																htmlFor={field.name}
																className="form-label"
															>
																{field.label}
															</label>
															{isSelect ? (
																<select
																	id={field.name}
																	name={field.name}
																	value={formik.values[field.name]}
																	onChange={formik.handleChange}
																	onBlur={formik.handleBlur}
																	className={`form-select text-end shadow-sm ${
																		formik.touched[field.name] &&
																		formik.errors[field.name]
																			? "is-invalid"
																			: ""
																	}`}
																	required={field.required}
																	disabled={formik.values[field.checkboxName]}
																>
																	<option value="" disabled>
																		{field.placeholder || "..."}
																	</option>
																	{field.options.map(
																		(option: string, i: number) => (
																			<option key={i} value={option}>
																				{option}
																			</option>
																		)
																	)}
																</select>
															) : (
																<input
																	type={field.type}
																	id={field.name}
																	name={field.name}
																	value={formik.values[field.name]}
																	onChange={formik.handleChange}
																	onBlur={formik.handleBlur}
																	className={`form-control text-end shadow-sm ${
																		formik.touched[field.name] &&
																		formik.errors[field.name]
																			? "is-invalid"
																			: ""
																	}`}
																	required={field.required}
																	disabled={formik.values[field.checkboxName]}
																	placeholder={field.placeholder || ""}
																/>
															)}
															{isCheckbox && field.checkboxLabel && (
																<div className="text-end mt-2">
																	<input
																		type="checkbox"
																		id={field.checkboxName}
																		name={field.checkboxName}
																		checked={Boolean(
																			formik.values[field.checkboxName]
																		)}
																		onChange={(e) => {
																			formik.setFieldValue(
																				field.checkboxName,
																				e.target.checked
																			);
																		}}
																		className="form-check-input shadow-sm"
																	/>
																	<label
																		htmlFor={field.checkboxName}
																		className="form-check-label ms-3"
																	>
																		{field.checkboxLabel}
																	</label>
																</div>
															)}
															{formik.touched[field.name] &&
																formik.errors[field.name] && (
																	<div className="invalid-feedback">
																		{formik.errors[field.name] as string}
																	</div>
																)}
														</div>
													);
												})}
										</div>
									</div>
								</div>
							</div>
						))}
					</div>
					<div className="d-flex justify-content-center my-3">
						<button
							type="submit"
							className="btn btn-primary rounded-pill text-white fs-4 px-5 py-2 shadow-sm"
						>
							ذخیره
						</button>
					</div>
				</form>
			</div>
		</div>
	);
}

export default UserIEInformation;
